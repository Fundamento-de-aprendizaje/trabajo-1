# Se debe tener instalado las siguientes librerias 
# pip install numpy pandas scikit-learn matplotlib

import numpy as snp
import pandas as pd
from funciones import calcularMetricas, find_s, aplicarHipotesis, calcularMatrizDeConfusion, separarDatosEnConjuntos, entrenar_naive_bayes, predecir_naive_bayes,calcular_curva_roc
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

print("PUNTO 1")
# leemos los datos del csv y le indicamos que columnas vamos a utilizar
url = 'https://drive.google.com/uc?export=download&id=1BQEFonHa5aYO4MTg1EWxGIuRSgCw6ZXb'
# leemos los datos del csv y le indicamos que columnas vamos a utilizar
datosPrestamos = pd.read_csv(url, usecols=[0, 1, 2, 5,12,13], encoding='latin1')

# Filtrar solo personas de 50 años. 
# Estamos haciendo una copia exacta de la lista de personas. Esta generando una nueva referencia.
personasDe50Anios = datosPrestamos[datosPrestamos['Edad'] == 50].values.tolist().copy() 

entrenamiento, prueba = separarDatosEnConjuntos(personasDe50Anios,0.75,False)
########################

# Llamar a la funcion Find-S
hypothesis = find_s(entrenamiento)

# Imprimimos los índicides del csv (Edad, sexo....)
print("La hipótesis final es:")

#print(datosPrestamos.columns.to_list())
print(datosPrestamos.columns.to_list()[:len(datosPrestamos.columns) -1])

# Mostrar la hipótesis final
print( "  ",hypothesis[0],"    ",hypothesis[1],"               ",
        hypothesis[2],"                ",hypothesis[3],"                     ",hypothesis[4])

# Estamos controlando la cantidad de personas total, 
print("\nCantidades obtenidas luego de filtrar a las personas de 50")
print( {"Total de personas con 50 años:": len(personasDe50Anios), "Entrenamiento": len(entrenamiento),"Prueba":len(prueba)})

# Llamar a la funcion aplicarHipotesis
prediccion= aplicarHipotesis(prueba,hypothesis)
print("\nAplicamos la Hipótesis al grupo de prueba y obtuvimos estos resultados")

print({
    "Prediccion": prediccion,
    "Aprobados de un total de": len(prueba),
    "Porcentaje": str(int(prediccion / len(prueba) * 100)) + " %"
})

############################################################
# PUNTO 2
print("\nPUNTO 2")
# Obtener los valores
TP, FP, TN, FN = calcularMatrizDeConfusion(prueba,hypothesis )

calcularMetricas(TP,FP,TN,FN)

###################################################
# PUNTO 3
print("\nPUNTO 3")
# Paso 1: Filtrar personas entre 40 y 45 años
personas_40_45 = datosPrestamos[(datosPrestamos['Edad'] >= 40) & (datosPrestamos['Edad'] <= 45)].copy()

# Convertir todas las columnas a tipo string para que sean categóricas
for col in personas_40_45.columns:
    personas_40_45[col] = personas_40_45[col].astype(str)

# Dividir aleatoriamente los datos en entrenamiento (80%) y prueba (20%)
entrenamiento, prueba = separarDatosEnConjuntos(personas_40_45.values.tolist(),0.8,True)

# Paso 2: Implementar Naive Bayes manualmente
# Entrenar el modelo
conteo_clases, conteo_atributos = entrenar_naive_bayes(entrenamiento)

# Paso 3: Evaluar el modelo en el conjunto de prueba
TP = FP = TN = FN = 0
y_true = []
y_scores = []

valores_posibles = {}

# Recorremos cada columna (sin contar la última que es la clase)
for i in range(len(entrenamiento[0]) - 1):
    valores_set = set()
    for fila in entrenamiento:
        valores_set.add(fila[i])
    valores_posibles[i] = list(valores_set)
#ACA QUEDAMOS///


for persona in prueba:
    total_datos = len(entrenamiento)
    prediccion, probabilidades = predecir_naive_bayes(persona, conteo_clases, conteo_atributos, total_datos, valores_posibles)
    verdadero_estado = persona[-1]
    y_true.append(1 if verdadero_estado == "OTORGADO" else 0)
    y_scores.append(probabilidades["OTORGADO"] if "OTORGADO" in probabilidades else 0)
    if prediccion == "OTORGADO":
        if verdadero_estado == "OTORGADO":
            TP += 1      #se etiquetó bien, la predicción fue correcta
        else:
            FP += 1      #está etiquetado como "OTORGADO" pero en realidad es "RECHAZADO"
    else:
        if verdadero_estado == "RECHAZADO":
            TN += 1      #se etiquetó bien, la predicción fue correcta ,está "RECHAZADO"
        else:
            FN += 1
# MATRIZ DE CONFUSÍON PUNTO 3"            
print("\nMATRIZ DE CONFUSION PUNTO 3\n")
print(" ",TP,  "|", FN , "\n ",FP ,"|" ,TN )   
print(f"\nTP (TRUE POSITIVE): {TP}")
print(f"FP (FALSE POSITIVE): {FP}")
print(f"TN (TRUE NEGATIVE): {TN}")
print(f"FN (FALSE NEGATIVE): {FN}\n")


# USAMOS UNA FUNCION PARA EL PUNTO 2 y 3. Para la parte de metricas.

calcularMetricas(TP,FP,TN,FN)

# Paso 5: Graficar la curva ROC


fpr, tpr = calcular_curva_roc(y_true, y_scores)

# Graficar la curva ROC

roc_auc = auc(fpr, tpr)

fig=plt.figure(figsize=(10, 8))
fig.patch.set_facecolor('#e6f2ff')
ax = plt.gca()  # obtiene el eje actual
ax.set_facecolor('black')  # o cualquier color: 'white', '#f0f0f0', 'black', etc.
plt.plot(fpr, tpr, color='#FF0B55', lw=2, label=f'Curva ROC (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='olive', linestyle='--')
plt.xlabel('Tasa de Falsos Positivos (FPR)')
plt.ylabel('Tasa de Verdaderos Positivos (TPR)')
plt.title('Curva ROC - Naive Bayes (40-45 años)')
plt.legend(loc="lower right")
plt.grid(True, color='gray', linestyle='--', linewidth=0.5)
plt.show()
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































